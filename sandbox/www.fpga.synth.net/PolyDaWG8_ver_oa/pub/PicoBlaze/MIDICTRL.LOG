KCPSM3 Assembler log file for program 'midictrl.psm'.
Generated by KCPSM3 version 1.30
Ken Chapman (Xilinx Ltd) 2005.
24Oct2008-19:02:57

 Addr Code

 000                            ; Program: MIDICTRL.psm (polyphonic)
 000                            ;  Author: Scott R. Gravenhorst
 000                            ;    Date: 01-25-2007
 000                            ;Rev date: 10-24-2008
 000                            ; Version: 1.23
 000                            ;----------------------------------------------------------------------------------------
 000                            ; Ver 1.03 Add control ports for 4 NCOs pitch values.
 000                            ; Ver 1.04 system exclusive message input implemetation
 000                            ;          sysex mfr ID 7F
 000                            ; Ver 1.05 Combine all single bit flags into one register.
 000                            ;          Attempt to combine byte counts into one register instead of two
 000                            ;          to facilitate register usage in more complex dual UART ISR.
 000                            ; Ver 1.06 Added parameter update via sysex.  Sysex data message is in address/data
 000                            ;          format.  Address currently starts at 0x20 and ends at 0x7F because sysex
 000                            ;          data values (including the address value) can't be larger than 0x7F.
 000                            ;          If ports become scarce, this can be chaged to also allow 0x00 - 0x1F at
 000                            ;          the expense of external circuitry rework.  Sysex data is applied to
 000                            ;          to synth by using the address value to select the port using a register
 000                            ;          as a port pointer. Note that no address range checking is performed.
 000                            ; Ver 1.07 Added selectable waveform NCOs
 000                            ; Ver 1.08 Remove sysex message type, add model number byte.
 000                            ; Ver 1.09 sysex address space changed to 00 to 7F from 20 to 7F
 000                            ; Ver 1.10 sysex address space expanded to 14 bits.
 000                            ; Ver 1.11 Add constant MIDI_TRANSPOSE.  This provides a way to give more range to the
 000                            ;          upper end of the keyboard for when large offsets used.  Without this
 000                            ;          constant (subtracted from all MIDI note numbers), this program will subtract
 000                            ;          octaves until the note number no longer has bit 7 set.  Actual pitch is then
 000                            ;          adjusted in the hardware in the NCO (nco_v8.v) module.  For the Korg
 000                            ;          Wavestation, I've found that hex 14 works well.
 000                            ; Ver 1.12 Add LCD Project name and author text.
 000                            ;
 000                            ; Ver 1.13 This file switches to the DWG synth, first version.
 000                            ;          Notes are presented in MIDI note number, not note - octave.
 000                            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 000                            ;
 000                            ;  POLYSYNTH...
 000                            ;
 000                            ; Ver 1.14 First polysynth, 2 strings.  Some of the notes above here no longer apply.
 000                            ; Ver 1.15 4 strings.
 000                            ; Ver 1.16 6 strings.
 000                            ; Ver 1.17 Piano like action, sustain pedal
 000                            ; Ver 1.18 8 strings.
 000                            ; Ver 1.19 Discovered a problem with the way the sustain pedal works.  rework here and
 000                            ;          in the main module (PolyDaWG8.v)
 000                            ; Ver 1.20 dual display for defining what mod wheel does.
 000                            ; Ver 1.21 Voices stolen from keys held down.  Hardware is different, ver_l required.
 000                            ; Ver 1.22 Changed LCD display of mode from N/O to Norm/Orig
 000                            ; Ver 1.23 Remove LCD code for Avnet board
 000                            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 000                            ;
 000                            ; MIDI UART input and synth control program.  Receives and interprets MIDI data.
 000                            ; MIDI support includes what Korg Wavestation can send.
 000                            ; note on/off, mod wheel, pitch wheel, joystick X and Y, channel pressure, sustain pedal.
 000                            ;
 000                            ; Note: DATAbyte1 represents the first data byte for commands which use 2 data bytes.
 000                            ;       DATAbyte2 represents the second data byte for commands which use 2 data bytes.
 000                            ;       DATAbyte2 represents the only data byte for commands which use 1 data byte.
 000                            ;
 000                            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 000                            CONSTANT MFR_ID, 7F                              ; my mfr ID - Change this if you want a different ID
 000                            CONSTANT MODEL_NUMBER, 01                        ; 00 = GateMan-I; 01 = PolyDaWG6
 000                            CONSTANT UNIT_NUMBER, 00                         ; unit number
 000                            CONSTANT MIDI_TRANSPOSE, 14                      ; how much to SUBTRACT from MIDI note numbers for note on/off messages
 000                            ; this gives more range on the high end
 000                            ; Bit definition constants as masks
 000                            CONSTANT rxready_bit, 02                         ; bit mask to sense for rx data available
 000                            CONSTANT MIDIbyteAVAILABLE_bit, 01               ; FLAGS register TEST mask
 000                            CONSTANT TTYbyteAVAILABLE_bit, 02                ; FLAGS register TEST mask
 000                            CONSTANT MESSAGEcomplete_bit, 04                 ; FLAGS register TEST mask
 000                            CONSTANT MIDIbyteAVAILABLE_set, 01               ; FLAGS register TEST mask
 000                            CONSTANT TTYbyteAVAILABLE_set, 02                ; FLAGS register TEST mask
 000                            CONSTANT MESSAGEcomplete_set, 04                 ; FLAGS register TEST mask
 000                            CONSTANT MIDIbyteAVAILABLE_clr, FE               ; FLAGS register TEST mask
 000                            CONSTANT TTYbyteAVAILABLE_clr, FD                ; FLAGS register TEST mask
 000                            CONSTANT MESSAGEcomplete_clr, FB                 ; FLAGS register TEST mask
 000                            CONSTANT MIDI_UARTstatus_bit, 40
 000                            CONSTANT TTY_UARTstatus_bit, 80
 000                            ; MIDI CONSTANTS
 000                            ; message type constants
 000                            CONSTANT K_NoteOff, 80
 000                            CONSTANT K_NoteOn, 90
 000                            CONSTANT K_PolyKeyPressure, A0
 000                            CONSTANT K_ControllerChange, B0
 000                            CONSTANT K_ProgramChange, C0
 000                            CONSTANT K_ChannelPressure, D0
 000                            CONSTANT K_PitchBend, E0
 000                            CONSTANT K_System, F0
 000                            ; Controller Change byte 1 constants:
 000                            CONSTANT MOD_WHEEL, 01
 000                            CONSTANT SUSTAIN, 40
 000                            CONSTANT JOYSTICK_X, 10                          ; Korg Wavestation, don't know about others.
 000                            CONSTANT JOYSTICK_Y, 11                          ; Korg Wavestation, don't know about others.
 000                            CONSTANT ALL_NOTES_OFF, 7B
 000                            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 000                            ;;;;;;;;;;;;;;;;;;
 000                            ;;;;;;;;;;;;;;;;;; READ ONLY PORTS:
 000                            ;;;;;;;;;;;;;;;;;;
 000                            ; UART
 000                            CONSTANT UARTstatusport, 00                      ; port number for rx and tx status (read only)
 000                            CONSTANT MIDIrxdataport, 01                      ; port number for rx data register (read only)
 000                            ; Slide switches
 000                            CONSTANT SWITCH_PORT, 02                         ; port number for slide switches (read only)
 000                            CONSTANT TTYrxdataport, 04                       ; port number for rx data register (read only)
 000                            CONSTANT TRANSPOSE, 03                           ; port number for transposition factor
 000                            CONSTANT MODWHEELSTATE, 05                       ; what state the mod wheel usage is in, bit 0
 000                            CONSTANT ACTIVE, 06                              ; vibrational state of each string, one bit per string
 000                            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 000                            ;;;;;;;;;;;;;;;;;;
 000                            ;;;;;;;;;;;;;;;;;; WRITE ONLY PORTS:
 000                            ;;;;;;;;;;;;;;;;;;
 000                            ; Global ports [02-0F], affect all voices:
 000                            CONSTANT CHANNEL_PRESSURE_PORT, F0               ; channel pressure value, global
 000                            CONSTANT PITCH_WHEEL_MSB_PORT, F1                ; pitch wheel MSB, global
 000                            CONSTANT PITCH_WHEEL_LSB_PORT, F2                ; pitch wheel LSB, global
 000                            CONSTANT MOD_WHEEL_PORT, 11                      ; modulation wheel, global
 000                            CONSTANT JOYSTICK_X_PORT, F4                     ; joystick X, global
 000                            CONSTANT JOYSTICK_Y_PORT, F5                     ; joystick Y, global
 000                            CONSTANT VOICE_SELECT_PORT, F6                   ; For poly, selects the voice to talk to when
 000                            ; sending or updating voice info.
 000                            CONSTANT SUSTAIN_PORT, 12                        ; FF when depressed, 00 when not depressed.
 000                            CONSTANT GATE_PORT, 13                           ; GATE signal, per voice
 000                            CONSTANT VEL0_PORT, 00                           ; ports for sending velocity (per voice) to synth
 000                            CONSTANT VEL1_PORT, 01
 000                            CONSTANT VEL2_PORT, 02
 000                            CONSTANT VEL3_PORT, 03
 000                            CONSTANT VEL4_PORT, 04
 000                            CONSTANT VEL5_PORT, 05
 000                            CONSTANT VEL6_PORT, 06
 000                            CONSTANT VEL7_PORT, 07
 000                            CONSTANT NOTE0_PORT, 08                          ; ports for sending note number (per voice) to synth
 000                            CONSTANT NOTE1_PORT, 09
 000                            CONSTANT NOTE2_PORT, 0A
 000                            CONSTANT NOTE3_PORT, 0B
 000                            CONSTANT NOTE4_PORT, 0C
 000                            CONSTANT NOTE5_PORT, 0D
 000                            CONSTANT NOTE6_PORT, 0E
 000                            CONSTANT NOTE7_PORT, 0F
 000                            CONSTANT LED_PORT, FE                            ; for diagnostics, may be removed later...
 000                            CONSTANT resetport, FF                           ; this port doesn't actually output anything.
 000                            ; Writing any data it's address resets the UART.
 000                            ;;;;;;;;;; SCRATCH PAD RAM ADDRESSES ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 000                            CONSTANT NOTE0, 20                               ; save the note number for lookup later (to manage note off messages)
 000                            CONSTANT NOTE1, 21
 000                            CONSTANT NOTE2, 22
 000                            CONSTANT NOTE3, 23
 000                            CONSTANT NOTE4, 24
 000                            CONSTANT NOTE5, 25
 000                            CONSTANT NOTE6, 26
 000                            CONSTANT NOTE7, 27
 000                            CONSTANT GATES, 30                               ; spRAM storage for maintaining the gates
 000                            CONSTANT ROUNDROBIN, 31                          ; used for selecting a "random" string when all are currently busy
 000                            CONSTANT SUS, 32                                 ; used to save sustain pedal state.
 000                            CONSTANT MIDIinputBYTE, 3E
 000                            CONSTANT TTYinputBYTE, 3F
 000                            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 000                            ; System Exclusive Message structure:
 000                            ; MFR ID
 000                            ; MODEL NUMBER
 000                            ; UNIT NUMBER
 000                            ; PARAMETER ADDRESS MSB
 000                            ; PARAMETER ADDRESS LSB
 000                            ; PARAMETER DATA
 000                            CONSTANT SYSEX_MSB_PORT, E0                      ; most significant 7 bits of the sysex address space
 000                            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 000                            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 000                            ; ports 00 through 7F are for sysex updatable registers
 000                            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 000                            ; Name and reserve registers.
 000                            NAMEREG s0, MIDIbyte                             ; latest received MIDI byte
 000                            NAMEREG s1, RUNNINGstatus                        ; holds the current MIDI running status value
 000                            NAMEREG s2, MessageTYPE                          ; Message type, i.e., high nybble
 000                            NAMEREG s3, MessageCHANNEL                       ; Message channel, i.e., low nybble
 000                            ; DATAbyteCOUNT is the counter that controls what happens to MIDI data bytes.
 000                            ; DATAbyteCOUNTrunstat holds the data byte count value to load into DATAbyteCOUNT to refresh
 000                            ; it when a message comes in assuming valid running status.
 000                            NAMEREG s4, DATAbyteCOUNT                        ; how many more bytes to satisfy the current message
 000                            NAMEREG s5, DATAbyteCOUNTrunstat                 ; holds replenishment value for DATAbyteCOUNT for running status
 000                            NAMEREG s6, DATAbyte1                            ; for current message storage of data byte 1
 000                            NAMEREG s7, DATAbyte2                            ; for current message storage of data byte 2
 000                            ;       1 means a complete MIDI message is ready to process
 000                            ; The code which processes this message will reset MESSAGE_COMPLETE to zero
 000                            ; s8  IS UNUSED
 000                            NAMEREG s9, COMMANDbyte                          ; command byte, contains command nybble and channel nybble of current message
 000                            NAMEREG sA, FLAGS                                ; FLAGS register contains single bit flags
 000                            NAMEREG sB, SYSEX                                ; sysex state machine state register
 000                            NAMEREG sC, UARTbyte                             ; incoming UART data byte, used by ISR
 000                            ; sD    used for destination pointer, considered temporary data storage
 000                            ; sE    used for a source pointer, considered temporary data storage.  sysex mode stores addr (port) here.
 000                            NAMEREG sF, TEMP                                 ; local loop or routine temp storage
 000                            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 000                            ;;;;;;;;;;;;;;;;;;;; CODE STARTS HERE ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 000                            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 000                            ADDRESS 000
 000                cold_start: 
 000                            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 000                            ; initialize storage
 000  2C2FF                     OUTPUT MessageTYPE[s2], resetport[FF]            ; Causes reset by addressing port 80-FF.  content doesn't matter.
 001  00000                     LOAD MIDIbyte[s0], 00
 002  00A00                     LOAD FLAGS[sA], 00
 003  00100                     LOAD RUNNINGstatus[s1], 00
 004  00400                     LOAD DATAbyteCOUNT[s4], 00
 005  00500                     LOAD DATAbyteCOUNTrunstat[s5], 00
 006  00600                     LOAD DATAbyte1[s6], 00
 007  00700                     LOAD DATAbyte2[s7], 00
 008  00B00                     LOAD SYSEX[sB], 00
 009  00F00                     LOAD TEMP[sF], 00
 00A  2CF13                     OUTPUT TEMP[sF], GATE_PORT[13]                   ; force GATEs off
 00B  2CF00                     OUTPUT TEMP[sF], VEL0_PORT[00]                   ; force VELOCITY to zero
 00C  2CF01                     OUTPUT TEMP[sF], VEL1_PORT[01]                   ; force VELOCITY to zero
 00D  2CF02                     OUTPUT TEMP[sF], VEL2_PORT[02]                   ; force VELOCITY to zero
 00E  2CF03                     OUTPUT TEMP[sF], VEL3_PORT[03]                   ; force VELOCITY to zero
 00F  2CF04                     OUTPUT TEMP[sF], VEL4_PORT[04]                   ; force VELOCITY to zero
 010  2CF05                     OUTPUT TEMP[sF], VEL5_PORT[05]                   ; force VELOCITY to zero
 011  2CF06                     OUTPUT TEMP[sF], VEL6_PORT[06]                   ; force VELOCITY to zero
 012  2CF07                     OUTPUT TEMP[sF], VEL7_PORT[07]                   ; force VELOCITY to zero
 013  2CFF2                     OUTPUT TEMP[sF], PITCH_WHEEL_LSB_PORT[F2]
 014  2CFF6                     OUTPUT TEMP[sF], VOICE_SELECT_PORT[F6]           ; for monosynth, set this to zero always.
 015  2EF30                     STORE TEMP[sF], GATES[30]                        ; ensure both gates are off at startup.
 016  2EF31                     STORE TEMP[sF], ROUNDROBIN[31]
 017  2EF32                     STORE TEMP[sF], SUS[32]
 018  00F40                     LOAD TEMP[sF], 40
 019  2CFF1                     OUTPUT TEMP[sF], PITCH_WHEEL_MSB_PORT[F1]
 01A  00FFF                     LOAD TEMP[sF], FF                                ; set no-keys-down flag
 01B  2EF00                     STORE TEMP[sF], 00                               ; store in RAM location 00
 01C  3C001                     ENABLE INTERRUPT
 01D                            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 01D                            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 01D                            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 01D                            ; Wait for and process MIDI Bytes.
 01D                            ; This is the main dispatch loop that monitors the ISR's MIDIbyteVALID flag register and MESSAGE_COMPLETE flag.
 01D                      idle: 
 01D  04F05                     INPUT TEMP[sF], MODWHEELSTATE[05]
 01E  12A04                     TEST FLAGS[sA], MESSAGEcomplete_bit[04]
 01F  35477                     JUMP NZ, ProcessMessage[077]
 020  12A01                     TEST FLAGS[sA], MIDIbyteAVAILABLE_bit[01]        ; see if isr set the byte available flag
 021  35427                     JUMP NZ, GetMIDIbyte[027]
 022  12A02                     TEST FLAGS[sA], TTYbyteAVAILABLE_bit[02]
 023  3501D                     JUMP Z, idle[01D]
 024                            ;GetTTYbyte:
 024  0603F                     FETCH MIDIbyte[s0], TTYinputBYTE[3F]
 025  0AAFD                     AND FLAGS[sA], TTYbyteAVAILABLE_clr[FD]          ; clear the MIDI byte available bit
 026  34029                     JUMP Procbyte[029]
 027               GetMIDIbyte: 
 027  0603E                     FETCH MIDIbyte[s0], MIDIinputBYTE[3E]
 028  0AAFE                     AND FLAGS[sA], MIDIbyteAVAILABLE_clr[FE]         ; clear the MIDI byte available bit
 029                            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 029                            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 029                  Procbyte: 
 029                            ; there is a byte to process
 029                            ; First test for active sensing byte - nothing but problems, so get rid of it now.
 029  140FE                     COMPARE MIDIbyte[s0], FE
 02A  3501D                     JUMP Z, idle[01D]
 02B  12080                     TEST MIDIbyte[s0], 80                            ; is high bit set?
 02C  3545E                     JUMP NZ, MIDI_STATUS_BYTE[05E]
 02D                            ; We have a data byte because bit 7 is zero.
 02D                            ; check if we're in sysex mode:
 02D  14B00                     COMPARE SYSEX[sB], 00
 02E  35056                     JUMP Z, PerformanceData[056]
 02F                            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 02F                            ; Deal with sysex message
 02F                            ; Sysexe is handled with a state machine.  Register SYSEX holds the current state.
 02F                            ; Setting the state to 7F causes the state machine to ignore the rest of any sysex message
 02F                            ; and wait for a F7 byte.
 02F                            ;
 02F  14B01                     COMPARE SYSEX[sB], 01
 030  3503D                     JUMP Z, CheckID[03D]                             ; check mfr ID
 031  14B02                     COMPARE SYSEX[sB], 02
 032  35042                     JUMP Z, ModelNumber[042]                         ; check model number
 033  14B03                     COMPARE SYSEX[sB], 03
 034  35047                     JUMP Z, UnitNumber[047]                          ; check unit number
 035  14B04                     COMPARE SYSEX[sB], 04
 036  3504C                     JUMP Z, ParameterAddrMSB[04C]                    ; set parameter address
 037  14B05                     COMPARE SYSEX[sB], 05
 038  35050                     JUMP Z, ParameterAddrLSB[050]
 039  14B06                     COMPARE SYSEX[sB], 06
 03A  35053                     JUMP Z, ParameterData[053]                       ; set parameter data
 03B  14B7F                     COMPARE SYSEX[sB], 7F
 03C                            ;  JUMP Z, idle                              ; we just jump to idle to simply wait for F7 to turn off sysex mode
 03C                            ; above instruction removed because we go idle regardless
 03C  3401D                     JUMP idle[01D]
 03D                   CheckID: 
 03D  00B02                     LOAD SYSEX[sB], 02                               ; move to next state, check UnitNumber
 03E  1407F                     COMPARE MIDIbyte[s0], MFR_ID[7F]                 ; this device's mfr ID
 03F  3501D                     JUMP Z, idle[01D]                                ; if this is ours, go to idle and wait
 040  00B7F                     LOAD SYSEX[sB], 7F                               ; not our message, bypass rest of message.
 041  3401D                     JUMP idle[01D]
 042               ModelNumber: 
 042  00B03                     LOAD SYSEX[sB], 03
 043  14001                     COMPARE MIDIbyte[s0], MODEL_NUMBER[01]
 044  3501D                     JUMP Z, idle[01D]                                ; if this is ours, go to idle and wait
 045  00B7F                     LOAD SYSEX[sB], 7F                               ; not our message, bypass rest of message.
 046  3401D                     JUMP idle[01D]
 047                UnitNumber: 
 047  00B04                     LOAD SYSEX[sB], 04                               ; set for parameter addr MSB mode
 048  14000                     COMPARE MIDIbyte[s0], UNIT_NUMBER[00]            ; compare message type byte, 00=parameter
 049  3501D                     JUMP Z, idle[01D]
 04A  00B7F                     LOAD SYSEX[sB], 7F                               ; not our message, bypass rest of message.
 04B  3401D                     JUMP idle[01D]
 04C          ParameterAddrMSB: 
 04C  00B05                     LOAD SYSEX[sB], 05                               ; set for parameter addr LSB mode
 04D  01E00                     LOAD sE, MIDIbyte[s0]                            ; get the MSB byte
 04E  2CEE0                     OUTPUT sE, SYSEX_MSB_PORT[E0]                    ; store the byte in the external parameter selection hardware
 04F  3401D                     JUMP idle[01D]
 050          ParameterAddrLSB: 
 050  00B06                     LOAD SYSEX[sB], 06                               ; set for parameter data mode
 051  01E00                     LOAD sE, MIDIbyte[s0]                            ; save the address byte in sE  NOTE: sE is temporary storage elsewhere, but should be safe here
 052  3401D                     JUMP idle[01D]
 053             ParameterData: 
 053  00B7F                     LOAD SYSEX[sB], 7F                               ; set to wait for F7
 054  2D0E0                     OUTPUT MIDIbyte[s0], (sE)                        ; send data byte to port number in sE (the address byte).
 055  3401D                     JUMP idle[01D]
 056                            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 056                            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 056           PerformanceData: 
 056  1C401                     SUB DATAbyteCOUNT[s4], 01                        ; decrement...
 057  3505A                     JUMP Z, byte2[05A]                               ; if equal to 0 now, it was 1, so this is byte2
 058  01600                     LOAD DATAbyte1[s6], MIDIbyte[s0]                 ; save this byte as data byte 1
 059  3401D                     JUMP idle[01D]
 05A                     byte2: ; in all cases, this is the last data byte.  Save it and set MESSAGE_COMPLETE
 05A  01700                     LOAD DATAbyte2[s7], MIDIbyte[s0]                 ; save this byte as data byte 2
 05B  0CA04                     OR FLAGS[sA], MESSAGEcomplete_set[04]            ; set message complete bit
 05C  01450                     LOAD DATAbyteCOUNT[s4], DATAbyteCOUNTrunstat[s5] ; set the count again, next message could be running status data.
 05D  3401D                     JUMP idle[01D]
 05E                            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 05E                            ; This is a status or command byte.
 05E          MIDI_STATUS_BYTE: ; high bit is set, now determine what sort of message this is
 05E  01200                     LOAD MessageTYPE[s2], MIDIbyte[s0]
 05F  01300                     LOAD MessageCHANNEL[s3], MIDIbyte[s0]
 060  0A2F0                     AND MessageTYPE[s2], F0                          ; MessageTYPE now contains only upper nybble of MIDI command/status byte.
 061  0A30F                     AND MessageCHANNEL[s3], 0F                       ; MessageCHANNEL contains only the channel nybble
 062  142F0                     COMPARE MessageTYPE[s2], K_System[F0]            ; If high nybble == F, then this is a special message
 063  3546C                     JUMP NZ, NotFx[06C]
 064                            ; We are here because this byte if Fx
 064                            ; decode and act on other Fx messages here.  For now, it's just a jump to idle
 064  140F7                     COMPARE MIDIbyte[s0], F7                         ; end of sysex message
 065  35468                     JUMP NZ, NotF7[068]
 066  00B00                     LOAD SYSEX[sB], 00                               ; sysex off.
 067  3401D                     JUMP idle[01D]
 068                     NotF7: 
 068  140F0                     COMPARE MIDIbyte[s0], F0                         ; F0 ?  (start of sysex message)
 069  3541D                     JUMP NZ, idle[01D]
 06A                            ; We have an F0
 06A  00B01                     LOAD SYSEX[sB], 01                               ; set sysex state flag to check mfr ID
 06B  3401D                     JUMP idle[01D]
 06C                     NotFx: 
 06C  00B00                     LOAD SYSEX[sB], 00                               ; sysex always goes off on any status byte.
 06D  01900                     LOAD COMMANDbyte[s9], MIDIbyte[s0]               ; remember this message's command byte.
 06E  142C0                     COMPARE MessageTYPE[s2], K_ProgramChange[C0]     ; is this PROGRAM CHANGE ?
 06F  35074                     JUMP Z, ONE_DATA_BYTE[074]
 070  142D0                     COMPARE MessageTYPE[s2], K_ChannelPressure[D0]   ; is this CHANNEL PRESSURE ?
 071  35074                     JUMP Z, ONE_DATA_BYTE[074]
 072  00402                     LOAD DATAbyteCOUNT[s4], 02                       ; If not channel pressure or program change, then 2 bytes of data
 073  34075                     JUMP SetCount[075]
 074             ONE_DATA_BYTE: 
 074  00401                     LOAD DATAbyteCOUNT[s4], 01
 075                            ; set count source for replenishing DATAbyteCOUNT when no status byte is sent (running status)
 075                  SetCount: 
 075  01540                     LOAD DATAbyteCOUNTrunstat[s5], DATAbyteCOUNT[s4]
 076  3401D                     JUMP idle[01D]
 077                            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 077                            ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ;
 077                            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 077                            ; A complete message is ready to process...
 077                            ; Message type determines the number of data bytes.
 077            ProcessMessage: 
 077  0AAFB                     AND FLAGS[sA], MESSAGEcomplete_clr[FB]           ; clear the message complete flag
 078                            ; See if this is our message.  If not, go idle, if yes, do the message.
 078  01F90                     LOAD TEMP[sF], COMMANDbyte[s9]                   ; get the current command byte into TEMP
 079  0AF0F                     AND TEMP[sF], 0F                                 ; isolate only the channel.
 07A  04D02                     INPUT sD, SWITCH_PORT[02]                        ; get current MIDI channel number for this hardware
 07B  15DF0                     COMPARE sD, TEMP[sF]                             ; compare MIDI channel setting with current running status channel number
 07C  3541D                     JUMP NZ, idle[01D]                               ; JUMP to idle if not our channel number.
 07D  01190                     LOAD RUNNINGstatus[s1], COMMANDbyte[s9]          ; this is a message on my channel so set running status.
 07E  01210                     LOAD MessageTYPE[s2], RUNNINGstatus[s1]
 07F  0A2F0                     AND MessageTYPE[s2], F0                          ; get message type nybble
 080                            ; This is where we act on complete messages.
 080                            ; JUMP table of vectors to different message type needs.
 080  14280                     COMPARE MessageTYPE[s2], K_NoteOff[80]
 081  3508F                     JUMP Z, NOTE_OFF[08F]
 082  14290                     COMPARE MessageTYPE[s2], K_NoteOn[90]
 083  3508F                     JUMP Z, NOTE_ON[08F]
 084  142A0                     COMPARE MessageTYPE[s2], K_PolyKeyPressure[A0]
 085  3514D                     JUMP Z, POLY_KEY_PRESSURE[14D]
 086  142B0                     COMPARE MessageTYPE[s2], K_ControllerChange[B0]
 087  35131                     JUMP Z, CONTROLLER_CHANGE[131]
 088  142C0                     COMPARE MessageTYPE[s2], K_ProgramChange[C0]
 089  3514D                     JUMP Z, PROGRAM_CHANGE[14D]
 08A  142D0                     COMPARE MessageTYPE[s2], K_ChannelPressure[D0]
 08B  35148                     JUMP Z, CHANNEL_PRESSURE[148]
 08C  142E0                     COMPARE MessageTYPE[s2], K_PitchBend[E0]
 08D  3514A                     JUMP Z, PITCH_BEND[14A]
 08E  3401D                     JUMP idle[01D]                                   ; anything else, toss.
 08F                            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 08F                            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 08F                            ;; This section will:
 08F                            ;; toggle the gate signal if it's on.
 08F                            ;; turn gate on if it's off.
 08F                            ;;
 08F                   NOTE_ON: 
 08F                  NOTE_OFF: 
 08F                            ;SET_SYNTH:
 08F  04803                     INPUT s8, TRANSPOSE[03]                          ; sample the value of TRANSPOSE port
 090  14700                     COMPARE DATAbyte2[s7], 00                        ; is velocity zero?
 091  354CE                     JUMP NZ, PLUCK[0CE]                              ; If not, we pluck a string
 092                            ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ;
 092                   RELEASE: 
 092                            ; "Release" refers to when the synth key is released.
 092                            ; Determine to which string the note-off message belongs.
 092                            ; The current note numbers are stored in scratch pad RAM
 092                            ; NOTE0 - NOTE7 and velocity values of VEL0 - VEL7
 092  06E30                     FETCH sE, GATES[30]                              ; get current gates state
 093                  TRYREL01: 
 093  12E01                     TEST sE, 01                                      ; is bit 0 on?
 094  35098                     JUMP Z, TRYREL02[098]
 095  06D20                     FETCH sD, NOTE0[20]
 096  15D60                     COMPARE sD, DATAbyte1[s6]
 097  350BC                     JUMP Z, REL0[0BC]
 098                  TRYREL02: 
 098  12E02                     TEST sE, 02                                      ; is bit 1 on?
 099  3509D                     JUMP Z, TRYREL04[09D]
 09A  06D21                     FETCH sD, NOTE1[21]
 09B  15D60                     COMPARE sD, DATAbyte1[s6]
 09C  350BE                     JUMP Z, REL1[0BE]
 09D                  TRYREL04: 
 09D  12E04                     TEST sE, 04                                      ; is bit 2 on?
 09E  350A2                     JUMP Z, TRYREL08[0A2]
 09F  06D22                     FETCH sD, NOTE2[22]
 0A0  15D60                     COMPARE sD, DATAbyte1[s6]
 0A1  350C0                     JUMP Z, REL2[0C0]
 0A2                  TRYREL08: 
 0A2  12E08                     TEST sE, 08                                      ; is bit 3 on?
 0A3  350A7                     JUMP Z, TRYREL10[0A7]
 0A4  06D23                     FETCH sD, NOTE3[23]
 0A5  15D60                     COMPARE sD, DATAbyte1[s6]
 0A6  350C2                     JUMP Z, REL3[0C2]
 0A7                  TRYREL10: 
 0A7  12E10                     TEST sE, 10                                      ; is bit 4 on?
 0A8  350AC                     JUMP Z, TRYREL20[0AC]
 0A9  06D24                     FETCH sD, NOTE4[24]
 0AA  15D60                     COMPARE sD, DATAbyte1[s6]
 0AB  350C4                     JUMP Z, REL4[0C4]
 0AC                  TRYREL20: 
 0AC  12E20                     TEST sE, 20                                      ; is bit 5 on?
 0AD  350B1                     JUMP Z, TRYREL40[0B1]
 0AE  06D25                     FETCH sD, NOTE5[25]
 0AF  15D60                     COMPARE sD, DATAbyte1[s6]
 0B0  350C6                     JUMP Z, REL5[0C6]
 0B1                  TRYREL40: 
 0B1  12E40                     TEST sE, 40                                      ; is bit 6 on?
 0B2  350B6                     JUMP Z, TRYREL80[0B6]
 0B3  06D26                     FETCH sD, NOTE6[26]
 0B4  15D60                     COMPARE sD, DATAbyte1[s6]
 0B5  350C8                     JUMP Z, REL6[0C8]
 0B6                  TRYREL80: 
 0B6  12E80                     TEST sE, 80                                      ; is bit 7 on?
 0B7  350BB                     JUMP Z, NONEBUSY[0BB]
 0B8  06D27                     FETCH sD, NOTE7[27]
 0B9  15D60                     COMPARE sD, DATAbyte1[s6]
 0BA  350CA                     JUMP Z, REL7[0CA]
 0BB                  NONEBUSY: 
 0BB                            ; If we are here, we didn't find the current note number in the strings note number table
 0BB  3401D                     JUMP idle[01D]                                   ; What else can I do?
 0BC                      REL0: 
 0BC  0AEFE                     AND sE, FE                                       ; sE has new GATES value
 0BD  340CB                     JUMP relsave[0CB]
 0BE                      REL1: 
 0BE  0AEFD                     AND sE, FD                                       ; sE has new GATES value
 0BF  340CB                     JUMP relsave[0CB]
 0C0                      REL2: 
 0C0  0AEFB                     AND sE, FB                                       ; sE has new GATES value
 0C1  340CB                     JUMP relsave[0CB]
 0C2                      REL3: 
 0C2  0AEF7                     AND sE, F7                                       ; sE has new GATES value
 0C3  340CB                     JUMP relsave[0CB]
 0C4                      REL4: 
 0C4  0AEEF                     AND sE, EF                                       ; sE has new GATES value
 0C5  340CB                     JUMP relsave[0CB]
 0C6                      REL5: 
 0C6  0AEDF                     AND sE, DF                                       ; sE has new GATES value
 0C7  340CB                     JUMP relsave[0CB]
 0C8                      REL6: 
 0C8  0AEBF                     AND sE, BF                                       ; sE has new GATES value
 0C9  340CB                     JUMP relsave[0CB]
 0CA                      REL7: 
 0CA  0AE7F                     AND sE, 7F                                       ; sE has new GATES value
 0CB                            ;  JUMP relsave  ; not necessary
 0CB                   relsave: ; save the new GATES state upon release
 0CB  2EE30                     STORE sE, GATES[30]                              ; update SP RAM
 0CC  2CE13                     OUTPUT sE, GATE_PORT[13]                         ; update synth hardware
 0CD  3401D                     JUMP idle[01D]                                   ; finished processing the note-off
 0CE                            ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ;
 0CE                     PLUCK: 
 0CE                            ; determine which string to use
 0CE  06F32                     FETCH TEMP[sF], SUS[32]                          ; Check sustain pedal state
 0CF  14F00                     COMPARE TEMP[sF], 00                             ; note: FETCH instruction does not change flags
 0D0  350D3                     JUMP Z, PEDALUP[0D3]
 0D1                            ; The pedal is held down.  So first try to use an inactive voice before stealing
 0D1  04F06                     INPUT TEMP[sF], ACTIVE[06]                       ; get vibrational state of all strings
 0D2  340D4                     JUMP STRINGTEST[0D4]
 0D3                            ; First look for an unused voice by checking for unbusy voices.
 0D3                            ; This needs to take into account that some keys can be held down
 0D3                            ; and should not be stolen if there are any unbusy voices.
 0D3                   PEDALUP: 
 0D3  06F30                     FETCH TEMP[sF], GATES[30]                        ; first get the state of the gates.
 0D4                STRINGTEST: 
 0D4  12F01                     TEST TEMP[sF], 01                                ; check if this voice is a held key
 0D5  350FA                     JUMP Z, PLUCK0[0FA]                              ; voice is idle, pluck it.
 0D6  12F02                     TEST TEMP[sF], 02                                ; check if this voice is a held key
 0D7  35100                     JUMP Z, PLUCK1[100]                              ; voice is idle, pluck it.
 0D8  12F04                     TEST TEMP[sF], 04                                ; check if this voice is a held key
 0D9  35106                     JUMP Z, PLUCK2[106]                              ; voice is idle, pluck it.
 0DA  12F08                     TEST TEMP[sF], 08                                ; check if this voice is a held key
 0DB  3510C                     JUMP Z, PLUCK3[10C]                              ; voice is idle, pluck it.
 0DC  12F10                     TEST TEMP[sF], 10                                ; check if this voice is a held key
 0DD  35112                     JUMP Z, PLUCK4[112]                              ; voice is idle, pluck it.
 0DE  12F20                     TEST TEMP[sF], 20                                ; check if this voice is a held key
 0DF  35118                     JUMP Z, PLUCK5[118]                              ; voice is idle, pluck it.
 0E0  12F40                     TEST TEMP[sF], 40                                ; check if this voice is a held key
 0E1  3511E                     JUMP Z, PLUCK6[11E]                              ; voice is idle, pluck it.
 0E2  12F80                     TEST TEMP[sF], 80                                ; check if this voice is a held key
 0E3  35124                     JUMP Z, PLUCK7[124]                              ; voice is idle, pluck it.
 0E4                            ; If we fall through to here, all voices are busy.
 0E4                            ; assign with round robin when all voices are busy
 0E4                            ; This algorithm will steal a voice that is already busy
 0E4  06E31                     FETCH sE, ROUNDROBIN[31]
 0E5  350F8                     JUMP Z, RR1[0F8]                                 ; if zero, go load a 01
 0E6  20E06                     SL0 sE                                           ; shift left for next cycle
 0E7  2EE31                     STORE sE, ROUNDROBIN[31]                         ; store for next cycle - hence "round robin"
 0E8  12E01                     TEST sE, 01                                      ; sE contains string to be plucked, check each
 0E9  354FA                     JUMP NZ, PLUCK0[0FA]                             ; string bit for 1 and vector to the pluck code for it.
 0EA  12E02                     TEST sE, 02
 0EB  35500                     JUMP NZ, PLUCK1[100]
 0EC  12E04                     TEST sE, 04
 0ED  35506                     JUMP NZ, PLUCK2[106]
 0EE  12E08                     TEST sE, 08
 0EF  3550C                     JUMP NZ, PLUCK3[10C]
 0F0  12E10                     TEST sE, 10
 0F1  35512                     JUMP NZ, PLUCK4[112]
 0F2  12E20                     TEST sE, 20
 0F3  35518                     JUMP NZ, PLUCK5[118]
 0F4  12E40                     TEST sE, 40
 0F5  3551E                     JUMP NZ, PLUCK6[11E]
 0F6  12E80                     TEST sE, 80
 0F7  35524                     JUMP NZ, PLUCK7[124]
 0F8                       RR1: 
 0F8  00E01                     LOAD sE, 01                                      ; load a one
 0F9  2EE31                     STORE sE, ROUNDROBIN[31]                         ;   into ROUNDROBIN.
 0FA                            ;  JUMP PLUCK0   ; jump not necessary, fall through                ; use string 0
 0FA                            ; send note data to string we will pluck
 0FA                    PLUCK0: 
 0FA  2E620                     STORE DATAbyte1[s6], NOTE0[20]                   ; save note value in SP RAM
 0FB  1D680                     SUB DATAbyte1[s6], s8
 0FC  2C608                     OUTPUT DATAbyte1[s6], NOTE0_PORT[08]
 0FD  2C700                     OUTPUT DATAbyte2[s7], VEL0_PORT[00]
 0FE  00F01                     LOAD TEMP[sF], 01                                ; set gate flag bit 0, use string 0
 0FF  34129                     JUMP SendGATE[129]                               ; go sent the gate on signal
 100                    PLUCK1: 
 100  2E621                     STORE DATAbyte1[s6], NOTE1[21]
 101  1D680                     SUB DATAbyte1[s6], s8
 102  2C609                     OUTPUT DATAbyte1[s6], NOTE1_PORT[09]             ; update string 1 note value
 103  2C701                     OUTPUT DATAbyte2[s7], VEL1_PORT[01]
 104  00F02                     LOAD TEMP[sF], 02                                ; set gate flag bit 2, use string 1
 105  34129                     JUMP SendGATE[129]                               ; go sent the gate on signal
 106                    PLUCK2: 
 106  2E622                     STORE DATAbyte1[s6], NOTE2[22]
 107  1D680                     SUB DATAbyte1[s6], s8
 108  2C60A                     OUTPUT DATAbyte1[s6], NOTE2_PORT[0A]             ; update string 2 note value
 109  2C702                     OUTPUT DATAbyte2[s7], VEL2_PORT[02]
 10A  00F04                     LOAD TEMP[sF], 04                                ; set gate flag bit 4, use string 2
 10B  34129                     JUMP SendGATE[129]                               ; go sent the gate on signal
 10C                    PLUCK3: 
 10C  2E623                     STORE DATAbyte1[s6], NOTE3[23]
 10D  1D680                     SUB DATAbyte1[s6], s8
 10E  2C60B                     OUTPUT DATAbyte1[s6], NOTE3_PORT[0B]             ; update string 3 note value
 10F  2C703                     OUTPUT DATAbyte2[s7], VEL3_PORT[03]
 110  00F08                     LOAD TEMP[sF], 08                                ; set gate flag bit 8, use string 3
 111  34129                     JUMP SendGATE[129]                               ; go sent the gate on signal
 112                    PLUCK4: 
 112  2E624                     STORE DATAbyte1[s6], NOTE4[24]
 113  1D680                     SUB DATAbyte1[s6], s8
 114  2C60C                     OUTPUT DATAbyte1[s6], NOTE4_PORT[0C]             ; update string 4 note value
 115  2C704                     OUTPUT DATAbyte2[s7], VEL4_PORT[04]
 116  00F10                     LOAD TEMP[sF], 10                                ; set gate flag bit 10, use string 3
 117  34129                     JUMP SendGATE[129]                               ; go sent the gate on signal
 118                    PLUCK5: 
 118  2E625                     STORE DATAbyte1[s6], NOTE5[25]
 119  1D680                     SUB DATAbyte1[s6], s8
 11A  2C60D                     OUTPUT DATAbyte1[s6], NOTE5_PORT[0D]             ; update string 5 note value
 11B  2C705                     OUTPUT DATAbyte2[s7], VEL5_PORT[05]
 11C  00F20                     LOAD TEMP[sF], 20                                ; set gate flag bit 20 use string 3
 11D  34129                     JUMP SendGATE[129]                               ; go sent the gate on signal
 11E                    PLUCK6: 
 11E  2E626                     STORE DATAbyte1[s6], NOTE6[26]
 11F  1D680                     SUB DATAbyte1[s6], s8
 120  2C60E                     OUTPUT DATAbyte1[s6], NOTE6_PORT[0E]             ; update string 6 note value
 121  2C706                     OUTPUT DATAbyte2[s7], VEL6_PORT[06]
 122  00F40                     LOAD TEMP[sF], 40                                ; set gate flag bit 40use string 3
 123  34129                     JUMP SendGATE[129]                               ; go sent the gate on signal
 124                    PLUCK7: 
 124  2E627                     STORE DATAbyte1[s6], NOTE7[27]
 125  1D680                     SUB DATAbyte1[s6], s8
 126  2C60F                     OUTPUT DATAbyte1[s6], NOTE7_PORT[0F]             ; update string 7 note value
 127  2C707                     OUTPUT DATAbyte2[s7], VEL7_PORT[07]
 128  00F80                     LOAD TEMP[sF], 80                                ; set gate flag bit 80 use string 3
 129                            ;  JUMP SendGATE   ; fall through                            ; go sent the gate on signal
 129                            ; TEMP now contains a single bit which represents the gate to turn on.
 129                            ;
 129                            ; First force the gate in question off, XOR the pluck bit in TEMP with GATES, then
 129                            ; send the byte to gates.  If the GATES bit was on, it will go off.  If it was off
 129                            ; it will go on.  In the second case, the second OUTPUT instruction doesn't matter
 129                  SendGATE: 
 129  06D30                     FETCH sD, GATES[30]                              ; get current gates state
 12A  01EF0                     LOAD sE, TEMP[sF]                                ; copy the gate bit to turn on into sE for inversion
 12B  0FED0                     XOR sE, sD                                       ; XOR the pluck bit in TEMP with GATES
 12C  2CE13                     OUTPUT sE, GATE_PORT[13]                         ; update the synth
 12D  0DDF0                     OR sD, TEMP[sF]                                  ; OR in the gate we want to turn on with the current gates status
 12E  2CD13                     OUTPUT sD, GATE_PORT[13]                         ; update the gates status
 12F  2ED30                     STORE sD, GATES[30]                              ; save new gates state
 130  3401D                     JUMP idle[01D]
 131                            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 131                            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 131                            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 131                            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 131         CONTROLLER_CHANGE: ; handle mod wheel, sustain and joystick here
 131  14601                     COMPARE DATAbyte1[s6], MOD_WHEEL[01]
 132  35535                     JUMP NZ, tstCCsus[135]
 133  2C711                     OUTPUT DATAbyte2[s7], MOD_WHEEL_PORT[11]
 134  3401D                     JUMP idle[01D]
 135                  tstCCsus: 
 135  14640                     COMPARE DATAbyte1[s6], SUSTAIN[40]               ; is it a sustain message?
 136  3553A                     JUMP NZ, tstCCjoyx[13A]
 137  2C712                     OUTPUT DATAbyte2[s7], SUSTAIN_PORT[12]           ; update synth
 138  2E732                     STORE DATAbyte2[s7], SUS[32]                     ; save sustain state, (maybe) need it for release logic
 139  3401D                     JUMP idle[01D]
 13A                 tstCCjoyx: 
 13A  14610                     COMPARE DATAbyte1[s6], JOYSTICK_X[10]
 13B  3553E                     JUMP NZ, tstCCjoyy[13E]
 13C  2C7F4                     OUTPUT DATAbyte2[s7], JOYSTICK_X_PORT[F4]
 13D  3401D                     JUMP idle[01D]
 13E                 tstCCjoyy: 
 13E  14611                     COMPARE DATAbyte1[s6], JOYSTICK_Y[11]
 13F  35542                     JUMP NZ, tstCCallnotesoff[142]
 140  2C7F5                     OUTPUT DATAbyte2[s7], JOYSTICK_Y_PORT[F5]
 141  3401D                     JUMP idle[01D]
 142          tstCCallnotesoff: 
 142  1467B                     COMPARE DATAbyte1[s6], ALL_NOTES_OFF[7B]
 143  3541D                     JUMP NZ, idle[01D]                               ; we don't recognize this CC
 144  00D00                     LOAD sD, 00
 145  2ED30                     STORE sD, GATES[30]
 146  2CD13                     OUTPUT sD, GATE_PORT[13]
 147  3401D                     JUMP idle[01D]
 148                            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 148          CHANNEL_PRESSURE: ; handle channel pressure here
 148  2C7F0                     OUTPUT DATAbyte2[s7], CHANNEL_PRESSURE_PORT[F0]
 149  3401D                     JUMP idle[01D]
 14A                            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 14A                PITCH_BEND: 
 14A  2C7F1                     OUTPUT DATAbyte2[s7], PITCH_WHEEL_MSB_PORT[F1]
 14B  2C6F2                     OUTPUT DATAbyte1[s6], PITCH_WHEEL_LSB_PORT[F2]   ; Writing to this port triggers second buffer write of ext. 16 bit register.
 14C  3401D                     JUMP idle[01D]
 14D                            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 14D                            ;; IGNORE THESE MESSAGES
 14D                            ;; Here we just jump to the idle loop.  My keyboard can't send these, so I don't care.  Maybe you do?
 14D            PROGRAM_CHANGE: ; This synth doesn't react to this...
 14D         POLY_KEY_PRESSURE: ; This synth doesn't react to this...
 14D  3401D                     JUMP idle[01D]                                   ; so ignore
 14E                            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 14E                            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 14E                            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 14E                            ;; SUBROUTINES
 14E                            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 14E                            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 14E                            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 14E                            ;; ISR - Handles MIDI and TTY rx data arrivals
 14E                       isr: 
 14E  04C00                     INPUT UARTbyte[sC], UARTstatusport[00]           ; read both UARTs rx status bits
 14F  0ACC0                     AND UARTbyte[sC], C0                             ; only the bits 6 and 7
 150  0DAC0                     OR FLAGS[sA], UARTbyte[sC]                       ; save status bits in FLAGS register
 151  12A40                     TEST FLAGS[sA], MIDI_UARTstatus_bit[40]          ; is the MIDI UART status bit set? 40
 152  35156                     JUMP Z, test_TTY[156]                            ; if not, go test the TTY UART status bit
 153  04C01                     INPUT UARTbyte[sC], MIDIrxdataport[01]           ; MIDI UART status bit was set, update MIDIbyte
 154  2EC3E                     STORE UARTbyte[sC], MIDIinputBYTE[3E]
 155  0CA01                     OR FLAGS[sA], MIDIbyteAVAILABLE_set[01]          ; Notify idle loop that a new MIDI byte is available
 156                  test_TTY: 
 156  12A80                     TEST FLAGS[sA], TTY_UARTstatus_bit[80]           ; is the TTY UART status bit set?  80
 157  3515B                     JUMP Z, isr_exit[15B]                            ; if not, we're done
 158  04C04                     INPUT UARTbyte[sC], TTYrxdataport[04]            ; TTY UART status bit was set, update MIDIbyte
 159  2EC3F                     STORE UARTbyte[sC], TTYinputBYTE[3F]
 15A  0CA02                     OR FLAGS[sA], TTYbyteAVAILABLE_set[02]           ; Notify idle loop that a new TTY byte is available
 15B                  isr_exit: 
 15B  0AA3F                     AND FLAGS[sA], 3F                                ; turn off both UART rx status bits
 15C  38001                     RETURNI ENABLE                                   ; return from ISR, enable interrupts
 15D                            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 15D                            ;; Interrupt Vector
 15D                            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 3FF                            ADDRESS 3FF
 3FF  3414E                     JUMP isr[14E]
